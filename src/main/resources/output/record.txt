预处理源代码开始...
预处理源代码结束
====================Source C Code==================
#include <stdio.h>

int main() {
    int n;
    int i;
    int sum;
    int tmp;

    scanf("%d", &n);    
    sum = 0;

    for(i = 1; i <= n; i++) { 
        tmp = i % 2;
        if(tmp == 0) {
            sum = sum + i;
        } else {
            sum = sum - i * 2;
        
        } 
    }   

    printf("sum is %d", sum);

    return 0;
}

源代码标号开始...
源代码编号结束!
====================Labeled C Code==================
#include <stdio.h>                                // 1

int main() {                                      // 2
    int n;                                        // 2.1
    int i;                                        // 2.2
    int sum;                                      // 2.3
    int tmp;                                      // 2.4

    scanf("%d", &n);                              // 2.5
    sum = 0;                                      // 2.6

    for(i = 1; i <= n; i++) {                     // 2.7
        tmp = i % 2;                              // 2.7.1
        if(tmp == 0) {                            // 2.7.2
            sum = sum + i;                        // 2.7.2.1
        } else {                                  // 2.7.3
            sum = sum - i * 2;                    // 2.7.3.1
        
        }                                         // 2.7.4
    }                                             // 2.8

    printf("sum is %d", sum);                     // 2.9

    return 0;                                     // 2.10
}                                                 // 3

词法分析开始...
词法分析结束!
====================Lexer==================
(#, SHARP, 1)
(include, INCLUDE, 1)
(<, LT, 1)
(stdio.h, IDENTIFIER, 1)
(>, GT, 1)
(int, INT, 2)
(main, IDENTIFIER, 2)
((, LL_BRACKET, 2)
(), RL_BRACKET, 2)
({, LB_BRACKET, 2)
(int, INT, 2.1)
(n, IDENTIFIER, 2.1)
(;, SEMICOLON, 2.1)
(int, INT, 2.2)
(i, IDENTIFIER, 2.2)
(;, SEMICOLON, 2.2)
(int, INT, 2.3)
(sum, IDENTIFIER, 2.3)
(;, SEMICOLON, 2.3)
(int, INT, 2.4)
(tmp, IDENTIFIER, 2.4)
(;, SEMICOLON, 2.4)
(scanf, IDENTIFIER, 2.5)
((, LL_BRACKET, 2.5)
(", DOUBLE_QUOTE, 2.5)
(%d, STRING_CONSTANT, 2.5)
(", DOUBLE_QUOTE, 2.5)
(,, COMMA, 2.5)
(&, ADDRESS, 2.5)
(n, IDENTIFIER, 2.5)
(), RL_BRACKET, 2.5)
(;, SEMICOLON, 2.5)
(sum, IDENTIFIER, 2.6)
(=, ASSIGN, 2.6)
(0, DIGIT_CONSTANT, 2.6)
(;, SEMICOLON, 2.6)
(for, FOR, 2.7)
((, LL_BRACKET, 2.7)
(i, IDENTIFIER, 2.7)
(=, ASSIGN, 2.7)
(1, DIGIT_CONSTANT, 2.7)
(;, SEMICOLON, 2.7)
(i, IDENTIFIER, 2.7)
(<=, LET, 2.7)
(n, IDENTIFIER, 2.7)
(;, SEMICOLON, 2.7)
(i, IDENTIFIER, 2.7)
(++, SELF_PLUS, 2.7)
(), RL_BRACKET, 2.7)
({, LB_BRACKET, 2.7)
(tmp, IDENTIFIER, 2.7.1)
(=, ASSIGN, 2.7.1)
(i, IDENTIFIER, 2.7.1)
(%, MOD, 2.7.1)
(2, DIGIT_CONSTANT, 2.7.1)
(;, SEMICOLON, 2.7.1)
(if, IF, 2.7.2)
((, LL_BRACKET, 2.7.2)
(tmp, IDENTIFIER, 2.7.2)
(==, EQU, 2.7.2)
(0, DIGIT_CONSTANT, 2.7.2)
(), RL_BRACKET, 2.7.2)
({, LB_BRACKET, 2.7.2)
(sum, IDENTIFIER, 2.7.2.1)
(=, ASSIGN, 2.7.2.1)
(sum, IDENTIFIER, 2.7.2.1)
(+, PLUS, 2.7.2.1)
(i, IDENTIFIER, 2.7.2.1)
(;, SEMICOLON, 2.7.2.1)
(}, RB_BRACKET, 2.7.3)
(else, ELSE, 2.7.3)
({, LB_BRACKET, 2.7.3)
(sum, IDENTIFIER, 2.7.3.1)
(=, ASSIGN, 2.7.3.1)
(sum, IDENTIFIER, 2.7.3.1)
(-, MINUS, 2.7.3.1)
(i, IDENTIFIER, 2.7.3.1)
(*, MUL, 2.7.3.1)
(2, DIGIT_CONSTANT, 2.7.3.1)
(;, SEMICOLON, 2.7.3.1)
(}, RB_BRACKET, 2.7.4)
(}, RB_BRACKET, 2.8)
(printf, IDENTIFIER, 2.9)
((, LL_BRACKET, 2.9)
(", DOUBLE_QUOTE, 2.9)
(sum is %d, STRING_CONSTANT, 2.9)
(", DOUBLE_QUOTE, 2.9)
(,, COMMA, 2.9)
(sum, IDENTIFIER, 2.9)
(), RL_BRACKET, 2.9)
(;, SEMICOLON, 2.9)
(return, RETURN, 2.10)
(0, DIGIT_CONSTANT, 2.10)
(;, SEMICOLON, 2.10)
(}, RB_BRACKET, 3)

语法分析开始...
  include语句 : 语法合法
  变量声明语句 : 语法合法
  变量声明语句 : 语法合法
  变量声明语句 : 语法合法
  变量声明语句 : 语法合法
  函数调用语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  if-else语句 : 语法合法
  for语句 : 语法合法
  函数调用语句 : 语法合法
  表达式语句 : 语法合法
  return语句 : 语法合法
  函数定义 : 语法合法
语法分析结束!
====================Parser==================
( self: Sentence null null, father: null, left: null, right: null )
( self: Include null null, father: Sentence, left: null, right: FunctionStatement )
( self: # SHARP 1, father: Include, left: null, right: include )
( self: include INCLUDE 1, father: Include, left: #, right: < )
( self: < LT 1, father: Include, left: include, right: stdio.h )
( self: stdio.h IDENTIFIER 1, father: Include, left: <, right: > )
( self: > GT 1, father: Include, left: stdio.h, right: null )
( self: FunctionStatement null null, father: Sentence, left: Include, right: null )
( self: Type null null, father: FunctionStatement, left: null, right: FunctionName )
( self: int FIELD_TYPE 2, father: Type, left: null, right: null )
( self: FunctionName null null, father: FunctionStatement, left: Type, right: StateParameterList )
( self: main IDENTIFIER 2, father: FunctionName, left: null, right: null )
( self: StateParameterList null null, father: FunctionStatement, left: FunctionName, right: Sentence )
( self: Sentence null null, father: FunctionStatement, left: StateParameterList, right: null )
( self: Statement null null, father: Sentence, left: null, right: Statement )
( self: Type null null, father: Statement, left: null, right: n )
( self: int FIELD_TYPE 2.1, father: Type, left: null, right: null )
( self: n IDENTIFIER 2.1, father: Statement, left: Type, right: null )
( self: Statement null null, father: Sentence, left: Statement, right: Statement )
( self: Type null null, father: Statement, left: null, right: i )
( self: int FIELD_TYPE 2.2, father: Type, left: null, right: null )
( self: i IDENTIFIER 2.2, father: Statement, left: Type, right: null )
( self: Statement null null, father: Sentence, left: Statement, right: Statement )
( self: Type null null, father: Statement, left: null, right: sum )
( self: int FIELD_TYPE 2.3, father: Type, left: null, right: null )
( self: sum IDENTIFIER 2.3, father: Statement, left: Type, right: null )
( self: Statement null null, father: Sentence, left: Statement, right: FunctionCall )
( self: Type null null, father: Statement, left: null, right: tmp )
( self: int FIELD_TYPE 2.4, father: Type, left: null, right: null )
( self: tmp IDENTIFIER 2.4, father: Statement, left: Type, right: null )
( self: FunctionCall null null, father: Sentence, left: Statement, right: Assignment )
( self: scanf FUNCTION_NAME 2.5, father: FunctionCall, left: null, right: CallParameterList )
( self: CallParameterList null null, father: FunctionCall, left: scanf, right: null )
( self: %d STRING_CONSTANT 2.5, father: CallParameterList, left: null, right: & )
( self: & ADDRESS 2.5, father: CallParameterList, left: %d, right: n )
( self: n IDENTIFIER 2.5, father: CallParameterList, left: &, right: null )
( self: Assignment null null, father: Sentence, left: FunctionCall, right: Control )
( self: sum IDENTIFIER 2.6, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: sum, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 0 _Constant 2.6, father: Expression, left: null, right: null )
( self: Control ForControl 2.7, father: Sentence, left: Assignment, right: FunctionCall )
( self: Assignment null null, father: Control, left: null, right: Expression )
( self: i IDENTIFIER 2.7, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: i, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 1 _Constant 2.7, father: Expression, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: Control, left: Assignment, right: Sentence )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: i _Variable 2.7, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Operator )
( self: n _Variable 2.7, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: <= _Operator 2.7, father: Operator, left: null, right: null )
( self: Sentence null null, father: Control, left: Expression, right: Expression )
( self: Assignment null null, father: Sentence, left: null, right: Control )
( self: tmp IDENTIFIER 2.7.1, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: tmp, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: i _Variable 2.7.1, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 2 _Constant 2.7.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: % _Operator 2.7.1, father: Operator, left: null, right: null )
( self: Control IfElseControl null, father: Sentence, left: Assignment, right: null )
( self: IfControl null 2.7.2, father: Control, left: null, right: ElseControl )
( self: Expression SingleOrDoubleOperand null, father: IfControl, left: null, right: Sentence )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: tmp _Variable 2.7.2, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 0 _Constant 2.7.2, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: == _Operator 2.7.2, father: Operator, left: null, right: null )
( self: Sentence null null, father: IfControl, left: Expression, right: null )
( self: Assignment null null, father: Sentence, left: null, right: null )
( self: sum IDENTIFIER 2.7.2.1, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: sum, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: sum _Variable 2.7.2.1, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Operator )
( self: i _Variable 2.7.2.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: + _Operator 2.7.2.1, father: Operator, left: null, right: null )
( self: ElseControl null 2.7.3, father: Control, left: IfControl, right: null )
( self: Sentence null null, father: ElseControl, left: null, right: null )
( self: Assignment null null, father: Sentence, left: null, right: null )
( self: sum IDENTIFIER 2.7.3.1, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: sum, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: sum _Variable 2.7.3.1, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Expression )
( self: i _Variable 2.7.3.1, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 2 _Constant 2.7.3.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: Operator )
( self: * _Operator 2.7.3.1, father: Operator, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Operator, right: null )
( self: - _Operator 2.7.3.1, father: Operator, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: Control, left: Sentence, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Operator )
( self: i _Variable 2.7, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: ++ _Operator 2.7, father: Operator, left: null, right: null )
( self: FunctionCall null null, father: Sentence, left: Control, right: Return )
( self: printf FUNCTION_NAME 2.9, father: FunctionCall, left: null, right: CallParameterList )
( self: CallParameterList null null, father: FunctionCall, left: printf, right: null )
( self: sum is %d STRING_CONSTANT 2.9, father: CallParameterList, left: null, right: sum )
( self: sum IDENTIFIER 2.9, father: CallParameterList, left: sum is %d, right: null )
( self: Return null null, father: Sentence, left: FunctionCall, right: null )
( self: return RETURN 2.10, father: Return, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Return, left: return, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 0 _Constant 2.10, father: Expression, left: null, right: null )

目标码生成开始...
if-else语句验证开始...
待证 : if_else
==============目标码模式===============
<LOG-EXP>
cmpi 7,0,0,0
beq 7,.L1
<STA-LIST_1>
b .L2
.L1:
<STA-LIST_2>
.L2:

==============目标码模式命题===============
GPR[0] = <LOG-EXP>

GPR[0] < 0 -> CR[7] = b100
GPR[0] > 0 -> CR[7] = b010
GPR[0] == 0 -> CR[7] = b001

CR[7] == b100 -> PC = PC + 4
CR[7] == b010 -> PC = PC + 4
CR[7] == b001 -> PC = PC + @.L1

<STA-LIST_1>

PC = PC + @.L2

.L1:

<STA-LIST_2>

.L2:

==============命题推理结果===============
<LOG-EXP> < 0 -> PC = PC + 4
<LOG-EXP> > 0 -> PC = PC + 4
<LOG-EXP> == 0 -> PC = PC + @.L1

<STA-LIST_1>

PC = PC + @.L2

.L1:

<STA-LIST_2>

.L2:

=============推理出的语义================
<LOG-EXP> != 0 -> <STA-LIST_1>
<LOG-EXP> == 0 -> <STA-LIST_2>

σ-transfer :
<LOG-EXP> != 0 -> σ(<STA-LIST_1>)
<LOG-EXP> == 0 -> σ(<STA-LIST_2>)

=============给定的目标语义================
<LOG-EXP> != 0 -> σ(<STA-LIST_1>)
<LOG-EXP> == 0 -> σ(<STA-LIST_2>)

===============结论================
给定的目标语义和推理出的语义是否一致 : 
true
if-else语句验证结果 : 验证成功
if-else语句验证结束!

for语句验证开始...
待证 : for
==============目标码模式===============
<ASS-EXP_1>
b .L2
.L1:
<STA-LIST>
<ASS-EXP_2>
.L2:
<LOG-EXP>
cmpi 7,0,0,0
bne 7,.L1

==============目标码模式命题===============
<ASS-EXP_1>

PC = PC + @.L2

.L1:

<STA-LIST>

<ASS-EXP_2>

.L2:

GPR[0] = <LOG-EXP>

GPR[0] < 0 -> CR[7] = b100
GPR[0] > 0 -> CR[7] = b010
GPR[0] == 0 -> CR[7] = b001

CR[7] == b100 -> PC = PC + @.L1
CR[7] == b010 -> PC = PC + @.L1
CR[7] == b001 -> PC = PC + 4

=================循环交互证明算法===================
源目标语义 :
σ(<ASS-EXP_1>)

{<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** n
<LOG-EXP> == 0 -> skip

(1) n == 1
目标语义取 n = 1 :
σ(<ASS-EXP_1>)

<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]
<LOG-EXP> == 0 -> skip

推理出的语义为 :
<ASS-EXP_1>

<LOG-EXP> != 0 -> <STA-LIST>; <ASS-EXP_2>
<LOG-EXP> == 0 -> null

σ-transfer :
σ(<ASS-EXP_1>)

<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]
<LOG-EXP> == 0 -> skip

结论 :
n = 1时, 目标语义和推理出的语义一致

(2) n = N
假设成立 :
σ(<ASS-EXP_1>)

{<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** N
<LOG-EXP> == 0 -> skip

(3) n = N + 1
目标语义 :
σ(<ASS-EXP_1>)

{<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** (N + 1)
<LOG-EXP> == 0 -> skip

合并推理出的 n = 1 和 假设的 n = N 的语义 :
σ(<ASS-EXP_1>)

{<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** (N + 1)
<LOG-EXP> == 0 -> skip

结论 :
n = N + 1时, 目标语义和推理出的语义一致

综上，给定的目标语义和推理出的语义是否一致 :
true
for语句验证结果 : 验证成功
for语句验证结束!

目标码生成结束!
===================Assembler==================
	.section .rodata
	.align 2                               # 2.5
.LC0:	                                  # 2.5
	.string	"%d"                           # 2.5
	.align 2                               # 2.9
.LC5:	                                  # 2.9
	.string	"sum is %d"                    # 2.9

	.section ".text"
	.align 2                               # 2
	.globl main                            # 2
	.type main, @function                  # 2
main:	                                  # 2
	stwu 1,-16(1)                          # 2
	stw 31,12(1)                           # 2
	mr 31,1                                # 2

	lis 0,.LC0@ha                          # 2.5
	addic 10,0,.LC0@l                      # 2.5
	mr 3,10                                # 2.5
	addi 11,31,8                           # 2.5
	mr 4,11                                # 2.5
	crxor 6,6,6                            # 2.5
	bl __isoc99_scanf                      # 2.5

	li 0,0                                 # 2.6
	stw 0,16(31)                           # 2.6

	li 0,1                                 # 2.7
	stw 0,12(31)                           # 2.7

	b .L1                                  # 2.7
.L2:	                                   # 2.7
	lwz 0,12(31)                           # 2.7.1
	li 9,2                                 # 2.7.1
	divw 11,0,9                            # 2.7.1
	mullw 9,11,9                           # 2.7.1
	subf 0,9,0                             # 2.7.1
	stw 0,24(31)                           # 2.7.1

	lwz 0,24(31)                           # 2.7.1
	stw 0,20(31)                           # 2.7.1

	lwz 0,20(31)                           # 2.7.2
	li 9,0                                 # 2.7.2
	cmp 7,0,0,9                            # 2.7.2
	li 0,0                                 # 2.7.2
	li 9,1                                 # 2.7.2
	isel 0,9,0,30                          # 2.7.2
	stw 0,24(31)                           # 2.7.2

	lwz 0,24(31)                           # 2.7.2
	cmpi 7,0,0,0                           # 2.7.2
	beq 7,.L3                              # 2.7.2

	lwz 9,16(31)                           # 2.7.2.1
	lwz 0,12(31)                           # 2.7.2.1
	add 0,9,0                              # 2.7.2.1
	stw 0,24(31)                           # 2.7.2.1

	lwz 0,24(31)                           # 2.7.2.1
	stw 0,16(31)                           # 2.7.2.1

	b .L4                                  # 2.7.3
.L3:	                                   # 2.7.2

	lwz 9,12(31)                           # 2.7.3.1
	li 0,2                                 # 2.7.3.1
	mullw 0,9,0                            # 2.7.3.1
	stw 0,24(31)                           # 2.7.3.1

	lwz 9,16(31)                           # 2.7.3.1
	lwz 0,24(31)
	subf 0,9,0                             # 2.7.3.1
	stw 0,28(31)                           # 2.7.3.1

	lwz 0,28(31)                           # 2.7.3.1
	stw 0,16(31)                           # 2.7.3.1

.L4:	                                   # 2.7.3

	lwz 0,12(31)                           # 2.7
	addic 0,0,1                            # 2.7
	stw 0,12(31)                           # 2.7

.L1:	                                   # 2.7
	lwz 0,12(31)                           # 2.7
	lwz 9,8(31)                            # 2.7
	cmp 7,0,0,9                            # 2.7
	li 0,1                                 # 2.7
	isel 0,0,0,29                          # 2.7
	stw 0,24(31)                           # 2.7

	lwz 0,24(31)                           # 2.7
	cmpi 7,0,0,0                           # 2.7
	bne 7,.L2                              # 2.7

	lis 0,.LC5@ha                          # 2.9
	addic 0,0,.LC5@l                       # 2.9
	mr 3,0                                 # 2.9
	lwz 4,16(31)                           # 2.9
	crxor 6,6,6                            # 2.9
	bl printf                              # 2.9

	li 0,0                                 # 2.10
	mr 3,0                                 # 2.10
	addi 11,31,16                          # 2
	lwz 31,-4(11)                          # 2
	mr 1,11                                # 2
	blr                                    # 2
	.size main,.-main                      # 2
