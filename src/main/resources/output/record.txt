预处理源代码开始...
预处理源代码结束
====================Source C Code==================
#include <stdio.h>
#include <stdlib.h>

int main() {
    int a;
    int b;
    int c;
    int d;

    scanf("%d %d", &a, &b);
    c = 0;
    do {
        if (a % 2 == 0) {
            c = c - a * 2;
        }
        c = c + a * 2;
        a++;
    } while (a < b);
    printf("c is %d for the first time!", c);

    scanf("%d", &a);
    b = 1;
    c = b * b;
    while (c < a) {
        b++;
        c = b * b;
    }
    printf("The biggest sqrt root of %d is %d", a, b);


    
    for (a = 0; a < 10; a++) {
        b++;

    }
    
    return 0;
}

源代码标号开始...
源代码编号结束!
====================Labeled C Code==================
#include <stdio.h>                                // 1
#include <stdlib.h>                               // 2

int main() {                                      // 3
    int a;                                        // 3.1
    int b;                                        // 3.2
    int c;                                        // 3.3
    int d;                                        // 3.4

    scanf("%d %d", &a, &b);                       // 3.5
    c = 0;                                        // 3.6
    do {                                          // 3.7
        if (a % 2 == 0) {                         // 3.7.1
            c = c - a * 2;                        // 3.7.1.1
        }                                         // 3.7.2
        c = c + a * 2;                            // 3.7.3
        a++;                                      // 3.7.4
    } while (a < b);                              // 3.8
    printf("c is %d for the first time!", c);     // 3.9

    scanf("%d", &a);                              // 3.10
    b = 1;                                        // 3.11
    c = b * b;                                    // 3.12
    while (c < a) {                               // 3.13
        b++;                                      // 3.13.1
        c = b * b;                                // 3.13.2
    }                                             // 3.14
    printf("The biggest sqrt root of %d is %d", a, b);// 3.15


    
    for (a = 0; a < 10; a++) {                    // 3.16
        b++;                                      // 3.16.1

    }                                             // 3.17
    
    return 0;                                     // 3.18
}                                                 // 4

词法分析开始...
词法分析结束!
====================Lexer==================
(#, SHARP, 1)
(include, INCLUDE, 1)
(<, LT, 1)
(stdio.h, IDENTIFIER, 1)
(>, GT, 1)
(#, SHARP, 2)
(include, INCLUDE, 2)
(<, LT, 2)
(stdlib.h, IDENTIFIER, 2)
(>, GT, 2)
(int, INT, 3)
(main, IDENTIFIER, 3)
((, LL_BRACKET, 3)
(), RL_BRACKET, 3)
({, LB_BRACKET, 3)
(int, INT, 3.1)
(a, IDENTIFIER, 3.1)
(;, SEMICOLON, 3.1)
(int, INT, 3.2)
(b, IDENTIFIER, 3.2)
(;, SEMICOLON, 3.2)
(int, INT, 3.3)
(c, IDENTIFIER, 3.3)
(;, SEMICOLON, 3.3)
(int, INT, 3.4)
(d, IDENTIFIER, 3.4)
(;, SEMICOLON, 3.4)
(scanf, IDENTIFIER, 3.5)
((, LL_BRACKET, 3.5)
(", DOUBLE_QUOTE, 3.5)
(%d %d, STRING_CONSTANT, 3.5)
(", DOUBLE_QUOTE, 3.5)
(,, COMMA, 3.5)
(&, BIT_AND, 3.5)
(a, IDENTIFIER, 3.5)
(,, COMMA, 3.5)
(&, BIT_AND, 3.5)
(b, IDENTIFIER, 3.5)
(), RL_BRACKET, 3.5)
(;, SEMICOLON, 3.5)
(c, IDENTIFIER, 3.6)
(=, ASSIGN, 3.6)
(0, DIGIT_CONSTANT, 3.6)
(;, SEMICOLON, 3.6)
(do, DO, 3.7)
({, LB_BRACKET, 3.7)
(if, IF, 3.7.1)
((, LL_BRACKET, 3.7.1)
(a, IDENTIFIER, 3.7.1)
(%, MOD, 3.7.1)
(2, DIGIT_CONSTANT, 3.7.1)
(==, EQU, 3.7.1)
(0, DIGIT_CONSTANT, 3.7.1)
(), RL_BRACKET, 3.7.1)
({, LB_BRACKET, 3.7.1)
(c, IDENTIFIER, 3.7.1.1)
(=, ASSIGN, 3.7.1.1)
(c, IDENTIFIER, 3.7.1.1)
(-, MINUS, 3.7.1.1)
(a, IDENTIFIER, 3.7.1.1)
(*, MUL, 3.7.1.1)
(2, DIGIT_CONSTANT, 3.7.1.1)
(;, SEMICOLON, 3.7.1.1)
(}, RB_BRACKET, 3.7.2)
(c, IDENTIFIER, 3.7.3)
(=, ASSIGN, 3.7.3)
(c, IDENTIFIER, 3.7.3)
(+, PLUS, 3.7.3)
(a, IDENTIFIER, 3.7.3)
(*, MUL, 3.7.3)
(2, DIGIT_CONSTANT, 3.7.3)
(;, SEMICOLON, 3.7.3)
(a, IDENTIFIER, 3.7.4)
(++, SELF_PLUS, 3.7.4)
(;, SEMICOLON, 3.7.4)
(}, RB_BRACKET, 3.8)
(while, WHILE, 3.8)
((, LL_BRACKET, 3.8)
(a, IDENTIFIER, 3.8)
(<, LT, 3.8)
(b, IDENTIFIER, 3.8)
(), RL_BRACKET, 3.8)
(;, SEMICOLON, 3.8)
(printf, IDENTIFIER, 3.9)
((, LL_BRACKET, 3.9)
(", DOUBLE_QUOTE, 3.9)
(c is %d for the first time!, STRING_CONSTANT, 3.9)
(", DOUBLE_QUOTE, 3.9)
(,, COMMA, 3.9)
(c, IDENTIFIER, 3.9)
(), RL_BRACKET, 3.9)
(;, SEMICOLON, 3.9)
(scanf, IDENTIFIER, 3.10)
((, LL_BRACKET, 3.10)
(", DOUBLE_QUOTE, 3.10)
(%d, STRING_CONSTANT, 3.10)
(", DOUBLE_QUOTE, 3.10)
(,, COMMA, 3.10)
(&, BIT_AND, 3.10)
(a, IDENTIFIER, 3.10)
(), RL_BRACKET, 3.10)
(;, SEMICOLON, 3.10)
(b, IDENTIFIER, 3.11)
(=, ASSIGN, 3.11)
(1, DIGIT_CONSTANT, 3.11)
(;, SEMICOLON, 3.11)
(c, IDENTIFIER, 3.12)
(=, ASSIGN, 3.12)
(b, IDENTIFIER, 3.12)
(*, MUL, 3.12)
(b, IDENTIFIER, 3.12)
(;, SEMICOLON, 3.12)
(while, WHILE, 3.13)
((, LL_BRACKET, 3.13)
(c, IDENTIFIER, 3.13)
(<, LT, 3.13)
(a, IDENTIFIER, 3.13)
(), RL_BRACKET, 3.13)
({, LB_BRACKET, 3.13)
(b, IDENTIFIER, 3.13.1)
(++, SELF_PLUS, 3.13.1)
(;, SEMICOLON, 3.13.1)
(c, IDENTIFIER, 3.13.2)
(=, ASSIGN, 3.13.2)
(b, IDENTIFIER, 3.13.2)
(*, MUL, 3.13.2)
(b, IDENTIFIER, 3.13.2)
(;, SEMICOLON, 3.13.2)
(}, RB_BRACKET, 3.14)
(printf, IDENTIFIER, 3.15)
((, LL_BRACKET, 3.15)
(", DOUBLE_QUOTE, 3.15)
(The biggest sqrt root of %d is %d, STRING_CONSTANT, 3.15)
(", DOUBLE_QUOTE, 3.15)
(,, COMMA, 3.15)
(a, IDENTIFIER, 3.15)
(,, COMMA, 3.15)
(b, IDENTIFIER, 3.15)
(), RL_BRACKET, 3.15)
(;, SEMICOLON, 3.15)
(for, FOR, 3.16)
((, LL_BRACKET, 3.16)
(a, IDENTIFIER, 3.16)
(=, ASSIGN, 3.16)
(0, DIGIT_CONSTANT, 3.16)
(;, SEMICOLON, 3.16)
(a, IDENTIFIER, 3.16)
(<, LT, 3.16)
(10, DIGIT_CONSTANT, 3.16)
(;, SEMICOLON, 3.16)
(a, IDENTIFIER, 3.16)
(++, SELF_PLUS, 3.16)
(), RL_BRACKET, 3.16)
({, LB_BRACKET, 3.16)
(b, IDENTIFIER, 3.16.1)
(++, SELF_PLUS, 3.16.1)
(;, SEMICOLON, 3.16.1)
(}, RB_BRACKET, 3.17)
(return, RETURN, 3.18)
(0, DIGIT_CONSTANT, 3.18)
(;, SEMICOLON, 3.18)
(}, RB_BRACKET, 4)

语法分析开始...
  include语句 : 语法合法
  include语句 : 语法合法
  变量声明语句 : 语法合法
  变量声明语句 : 语法合法
  变量声明语句 : 语法合法
  变量声明语句 : 语法合法
  函数调用语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  if-else语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  do-while语句 : 语法合法
  函数调用语句 : 语法合法
  函数调用语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  while语句 : 语法合法
  函数调用语句 : 语法合法
  表达式语句 : 语法合法
  赋值语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  表达式语句 : 语法合法
  for语句 : 语法合法
  表达式语句 : 语法合法
  return语句 : 语法合法
  函数定义 : 语法合法
语法分析结束!
====================Parser==================
( self: Sentence null null, father: null, left: null, right: null )
( self: Include null null, father: Sentence, left: null, right: Include )
( self: # SHARP 1, father: Include, left: null, right: include )
( self: include INCLUDE 1, father: Include, left: #, right: < )
( self: < LT 1, father: Include, left: include, right: stdio.h )
( self: stdio.h IDENTIFIER 1, father: Include, left: <, right: > )
( self: > GT 1, father: Include, left: stdio.h, right: null )
( self: Include null null, father: Sentence, left: Include, right: FunctionStatement )
( self: # SHARP 2, father: Include, left: null, right: include )
( self: include INCLUDE 2, father: Include, left: #, right: < )
( self: < LT 2, father: Include, left: include, right: stdlib.h )
( self: stdlib.h IDENTIFIER 2, father: Include, left: <, right: > )
( self: > GT 2, father: Include, left: stdlib.h, right: null )
( self: FunctionStatement null null, father: Sentence, left: Include, right: null )
( self: Type null null, father: FunctionStatement, left: null, right: FunctionName )
( self: int FIELD_TYPE 3, father: Type, left: null, right: null )
( self: FunctionName null null, father: FunctionStatement, left: Type, right: StateParameterList )
( self: main IDENTIFIER 3, father: FunctionName, left: null, right: null )
( self: StateParameterList null null, father: FunctionStatement, left: FunctionName, right: Sentence )
( self: Sentence null null, father: FunctionStatement, left: StateParameterList, right: null )
( self: Statement null null, father: Sentence, left: null, right: Statement )
( self: Type null null, father: Statement, left: null, right: a )
( self: int FIELD_TYPE 3.1, father: Type, left: null, right: null )
( self: a IDENTIFIER 3.1, father: Statement, left: Type, right: null )
( self: Statement null null, father: Sentence, left: Statement, right: Statement )
( self: Type null null, father: Statement, left: null, right: b )
( self: int FIELD_TYPE 3.2, father: Type, left: null, right: null )
( self: b IDENTIFIER 3.2, father: Statement, left: Type, right: null )
( self: Statement null null, father: Sentence, left: Statement, right: Statement )
( self: Type null null, father: Statement, left: null, right: c )
( self: int FIELD_TYPE 3.3, father: Type, left: null, right: null )
( self: c IDENTIFIER 3.3, father: Statement, left: Type, right: null )
( self: Statement null null, father: Sentence, left: Statement, right: FunctionCall )
( self: Type null null, father: Statement, left: null, right: d )
( self: int FIELD_TYPE 3.4, father: Type, left: null, right: null )
( self: d IDENTIFIER 3.4, father: Statement, left: Type, right: null )
( self: FunctionCall null null, father: Sentence, left: Statement, right: Assignment )
( self: scanf FUNCTION_NAME 3.5, father: FunctionCall, left: null, right: CallParameterList )
( self: CallParameterList null null, father: FunctionCall, left: scanf, right: null )
( self: %d %d STRING_CONSTANT 3.5, father: CallParameterList, left: null, right: & )
( self: & ADDRESS 3.5, father: CallParameterList, left: %d %d, right: a )
( self: a IDENTIFIER 3.5, father: CallParameterList, left: &, right: & )
( self: & ADDRESS 3.5, father: CallParameterList, left: a, right: b )
( self: b IDENTIFIER 3.5, father: CallParameterList, left: &, right: null )
( self: Assignment null null, father: Sentence, left: FunctionCall, right: Control )
( self: c IDENTIFIER 3.6, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: c, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 0 _Constant 3.6, father: Expression, left: null, right: null )
( self: Control DoWhileControl 3.7, father: Sentence, left: Assignment, right: FunctionCall )
( self: Sentence null null, father: Control, left: null, right: Expression )
( self: Control IfElseControl null, father: Sentence, left: null, right: Assignment )
( self: IfControl null 3.7.1, father: Control, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: IfControl, left: null, right: Sentence )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: a _Variable 3.7.1, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 2 _Constant 3.7.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: Expression )
( self: % _Operator 3.7.1, father: Operator, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Operator, right: Operator )
( self: 0 _Constant 3.7.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: == _Operator 3.7.1, father: Operator, left: null, right: null )
( self: Sentence null null, father: IfControl, left: Expression, right: null )
( self: Assignment null null, father: Sentence, left: null, right: null )
( self: c IDENTIFIER 3.7.1.1, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: c, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: c _Variable 3.7.1.1, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Expression )
( self: a _Variable 3.7.1.1, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 2 _Constant 3.7.1.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: Operator )
( self: * _Operator 3.7.1.1, father: Operator, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Operator, right: null )
( self: - _Operator 3.7.1.1, father: Operator, left: null, right: null )
( self: Assignment null null, father: Sentence, left: Control, right: Expression )
( self: c IDENTIFIER 3.7.3, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: c, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: c _Variable 3.7.3, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Expression )
( self: a _Variable 3.7.3, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 2 _Constant 3.7.3, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: Operator )
( self: * _Operator 3.7.3, father: Operator, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Operator, right: null )
( self: + _Operator 3.7.3, father: Operator, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: Sentence, left: Assignment, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Operator )
( self: a _Variable 3.7.4, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: ++ _Operator 3.7.4, father: Operator, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: Control, left: Sentence, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: a _Variable 3.8, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Operator )
( self: b _Variable 3.8, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: < _Operator 3.8, father: Operator, left: null, right: null )
( self: FunctionCall null null, father: Sentence, left: Control, right: FunctionCall )
( self: printf FUNCTION_NAME 3.9, father: FunctionCall, left: null, right: CallParameterList )
( self: CallParameterList null null, father: FunctionCall, left: printf, right: null )
( self: c is %d for the first time! STRING_CONSTANT 3.9, father: CallParameterList, left: null, right: c )
( self: c IDENTIFIER 3.9, father: CallParameterList, left: c is %d for the first time!, right: null )
( self: FunctionCall null null, father: Sentence, left: FunctionCall, right: Assignment )
( self: scanf FUNCTION_NAME 3.10, father: FunctionCall, left: null, right: CallParameterList )
( self: CallParameterList null null, father: FunctionCall, left: scanf, right: null )
( self: %d STRING_CONSTANT 3.10, father: CallParameterList, left: null, right: & )
( self: & ADDRESS 3.10, father: CallParameterList, left: %d, right: a )
( self: a IDENTIFIER 3.10, father: CallParameterList, left: &, right: null )
( self: Assignment null null, father: Sentence, left: FunctionCall, right: Assignment )
( self: b IDENTIFIER 3.11, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: b, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 1 _Constant 3.11, father: Expression, left: null, right: null )
( self: Assignment null null, father: Sentence, left: Assignment, right: Control )
( self: c IDENTIFIER 3.12, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: c, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: b _Variable 3.12, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Operator )
( self: b _Variable 3.12, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: * _Operator 3.12, father: Operator, left: null, right: null )
( self: Control WhileControl 3.13, father: Sentence, left: Assignment, right: FunctionCall )
( self: Expression SingleOrDoubleOperand null, father: Control, left: null, right: Sentence )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: c _Variable 3.13, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Operator )
( self: a _Variable 3.13, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: < _Operator 3.13, father: Operator, left: null, right: null )
( self: Sentence null null, father: Control, left: Expression, right: null )
( self: Expression SingleOrDoubleOperand null, father: Sentence, left: null, right: Assignment )
( self: Expression Variable null, father: Expression, left: null, right: Operator )
( self: b _Variable 3.13.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: ++ _Operator 3.13.1, father: Operator, left: null, right: null )
( self: Assignment null null, father: Sentence, left: Expression, right: null )
( self: c IDENTIFIER 3.13.2, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: c, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: b _Variable 3.13.2, father: Expression, left: null, right: null )
( self: Expression Variable null, father: Expression, left: Expression, right: Operator )
( self: b _Variable 3.13.2, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: * _Operator 3.13.2, father: Operator, left: null, right: null )
( self: FunctionCall null null, father: Sentence, left: Control, right: Control )
( self: printf FUNCTION_NAME 3.15, father: FunctionCall, left: null, right: CallParameterList )
( self: CallParameterList null null, father: FunctionCall, left: printf, right: null )
( self: The biggest sqrt root of %d is %d STRING_CONSTANT 3.15, father: CallParameterList, left: null, right: a )
( self: a IDENTIFIER 3.15, father: CallParameterList, left: The biggest sqrt root of %d is %d, right: b )
( self: b IDENTIFIER 3.15, father: CallParameterList, left: a, right: null )
( self: Control ForControl 3.16, father: Sentence, left: FunctionCall, right: Return )
( self: Assignment null null, father: Control, left: null, right: Expression )
( self: a IDENTIFIER 3.16, father: Assignment, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Assignment, left: a, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 0 _Constant 3.16, father: Expression, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: Control, left: Assignment, right: Sentence )
( self: Expression Variable null, father: Expression, left: null, right: Expression )
( self: a _Variable 3.16, father: Expression, left: null, right: null )
( self: Expression Constant null, father: Expression, left: Expression, right: Operator )
( self: 10 _Constant 3.16, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: < _Operator 3.16, father: Operator, left: null, right: null )
( self: Sentence null null, father: Control, left: Expression, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Sentence, left: null, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Operator )
( self: b _Variable 3.16.1, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: ++ _Operator 3.16.1, father: Operator, left: null, right: null )
( self: Expression SingleOrDoubleOperand null, father: Control, left: Sentence, right: null )
( self: Expression Variable null, father: Expression, left: null, right: Operator )
( self: a _Variable 3.16, father: Expression, left: null, right: null )
( self: Operator Operator null, father: Expression, left: Expression, right: null )
( self: ++ _Operator 3.16, father: Operator, left: null, right: null )
( self: Return null null, father: Sentence, left: Control, right: null )
( self: return RETURN 3.18, father: Return, left: null, right: Expression )
( self: Expression SingleOrDoubleOperand null, father: Return, left: return, right: null )
( self: Expression Constant null, father: Expression, left: null, right: null )
( self: 0 _Constant 3.18, father: Expression, left: null, right: null )

目标码生成开始...
if语句验证开始...
if : 3.7.1

==============目标码模式===============
<LOG-EXP>
cmpi 7,0,0,0
beq 7,.L1
<STA-LIST>
.L1:

==============目标码模式命题===============
P1 = GPR[0] = <LOG-EXP>
P2 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001
P3 = CR[7] == b100 -> PC = PC + 4 || CR[7] == b010 -> PC = PC + 4 || CR[7] == b001 -> PC = PC + @.L1
P4 = <STA-LIST>
P5 = .L1:

==============推导序列===============
S1 = GPR[0] = <LOG-EXP>		P1
S2 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001		P2
S3 = <LOG-EXP> < 0 -> CR[7] = b100 || <LOG-EXP> > 0 -> CR[7] = b010 || <LOG-EXP> == 0 -> CR[7] = b001		S1,S2,MP
S4 = CR[7] == b100 -> PC = PC + 4 || CR[7] == b010 -> PC = PC + 4 || CR[7] == b001 -> PC = PC + @.L1		P3
S5 = <LOG-EXP> < 0 -> PC = PC + 4 || <LOG-EXP> > 0 -> PC = PC + 4 || <LOG-EXP> == 0 -> PC = PC + @.L1		S3,S4,MP
S6 = <STA-LIST>		P4
S7 = .L1:		P5
S8 = (<LOG-EXP> < 0 -> PC = PC + 4 || <LOG-EXP> > 0 -> PC = PC + 4 || <LOG-EXP> == 0 -> PC = PC + @.L1) ∧ (<STA-LIST>) ∧ (.L1:)		S5, S6, S7, CI
S9 = (<LOG-EXP> != 0 -> <STA-LIST> || <LOG-EXP> == 0 -> null)		S8, REDUCE
S10 = (<LOG-EXP> != 0 -> σ(<STA-LIST>) || <LOG-EXP> == 0 -> skip)		S9, σ

=============给定的目标语义================
<LOG-EXP> != 0 -> σ(<STA-LIST>) || <LOG-EXP> == 0 -> skip

===============结论================
给定的目标语义和推理出的语义是否一致 : 
true
if语句验证结果 : 验证成功
if语句验证结束!

do-while语句验证开始...
do_while : 3.7

==============目标码模式===============
.L1:
<STA-LIST>
<LOG-EXP>
cmpi 7,0,0,0
bne 7,.L1

==============目标码模式命题===============
P1 = .L1:
P2 = <STA-LIST>
P3 = GPR[0] = <LOG-EXP>
P4 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001
P5 = CR[7] == b100 -> PC = PC + @.L1 || CR[7] == b010 -> PC = PC + @.L1 || CR[7] == b001 -> PC = PC + 4

=================循环交互证明算法===================
用户输入的语义 :
σ(<STA-LIST>)
{<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** n || <LOG-EXP> == 0 -> skip

辅助前提 :
P0 = (σ(<STA-LIST>)) ∧ ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** n || <LOG-EXP> == 0 -> skip)

推导序列 :
S1 = .L1:		P1
S2 = <STA-LIST>		P2
S3 = GPR[0] = <LOG-EXP>		P3
S4 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001		P4
S5 = <LOG-EXP> < 0 -> CR[7] = b100 || <LOG-EXP> > 0 -> CR[7] = b010 || <LOG-EXP> == 0 -> CR[7] = b001		S3,S4,MP
S6 = CR[7] == b100 -> PC = PC + @.L1 || CR[7] == b010 -> PC = PC + @.L1 || CR[7] == b001 -> PC = PC + 4		P5
S7 = <LOG-EXP> < 0 -> PC = PC + @.L1 || <LOG-EXP> > 0 -> PC = PC + @.L1 || <LOG-EXP> == 0 -> PC = PC + 4		S5,S6,MP
S8 = (.L1:) ∧ (<STA-LIST>) ∧ (<LOG-EXP> < 0 -> PC = PC + @.L1 || <LOG-EXP> > 0 -> PC = PC + @.L1 || <LOG-EXP> == 0 -> PC = PC + 4)		S1, S2, S7, CI
S9 = (<STA-LIST>) ∧ (<LOG-EXP> != 0 -> <STA-LIST> || <LOG-EXP> == 0 -> null)		S8, REDUCE
S10 = (σ(<STA-LIST>)) ∧ (<LOG-EXP> != 0 -> σ(<STA-LIST>) || <LOG-EXP> == 0 -> skip)		S9, σ
S11 = (σ(<STA-LIST>)) ∧ ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** N || <LOG-EXP> == 0 -> skip)		P0, n = N
S12 = (σ(<STA-LIST>)) ∧ ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** (N + 1) || <LOG-EXP> == 0 -> skip)		S10, S11, CI

check(n == 1) :
目标语义 : (σ(<STA-LIST>)) ∧ (<LOG-EXP> != 0 -> σ(<STA-LIST>) || <LOG-EXP> == 0 -> skip)
推导序列证据 : S10
目标语义和推理出的语义是否一致 : true

check(n == N + 1) :
目标语义 : (σ(<STA-LIST>)) ∧ ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** (N + 1) || <LOG-EXP> == 0 -> skip)
推导序列证据 : S12
目标语义和推理出的语义是否一致 : true

综上，给定的目标语义和推理出的语义是否一致 :
true
do-while语句验证结果 : 验证成功
do-while语句验证结束!

while语句验证开始...
while : 3.13

==============目标码模式===============
b .L2
.L1:
<STA-LIST>
.L2:
<LOG-EXP>
cmpi 7,0,0,0
bne 7,.L1

==============目标码模式命题===============
P1 = PC = PC + @.L2
P2 = .L1:
P3 = <STA-LIST>
P4 = .L2:
P5 = GPR[0] = <LOG-EXP>
P6 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001
P7 = CR[7] == b100 -> PC = PC + @.L1 || CR[7] == b010 -> PC = PC + @.L1 || CR[7] == b001 -> PC = PC + 4

=================循环交互证明算法===================
用户输入的语义 :
{<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** n || <LOG-EXP> == 0 -> skip

辅助前提 :
P0 = ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** n || <LOG-EXP> == 0 -> skip)

推导序列 :
S1 = PC = PC + @.L2		P1
S2 = .L1:		P2
S3 = <STA-LIST>		P3
S4 = .L2:		P4
S5 = GPR[0] = <LOG-EXP>		P5
S6 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001		P6
S7 = <LOG-EXP> < 0 -> CR[7] = b100 || <LOG-EXP> > 0 -> CR[7] = b010 || <LOG-EXP> == 0 -> CR[7] = b001		S5,S6,MP
S8 = CR[7] == b100 -> PC = PC + @.L1 || CR[7] == b010 -> PC = PC + @.L1 || CR[7] == b001 -> PC = PC + 4		P7
S9 = <LOG-EXP> < 0 -> PC = PC + @.L1 || <LOG-EXP> > 0 -> PC = PC + @.L1 || <LOG-EXP> == 0 -> PC = PC + 4		S7,S8,MP
S10 = (PC = PC + @.L2) ∧ (.L1:) ∧ (<STA-LIST>) ∧ (.L2:) ∧ (<LOG-EXP> < 0 -> PC = PC + @.L1 || <LOG-EXP> > 0 -> PC = PC + @.L1 || <LOG-EXP> == 0 -> PC = PC + 4)		S1, S2, S3, S4, S9, CI
S11 = (<LOG-EXP> != 0 -> <STA-LIST> || <LOG-EXP> == 0 -> null)		S10, REDUCE
S12 = (<LOG-EXP> != 0 -> σ(<STA-LIST>) || <LOG-EXP> == 0 -> skip)		S11, σ
S13 = ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** N || <LOG-EXP> == 0 -> skip)		P0, n = N
S14 = ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** (N + 1) || <LOG-EXP> == 0 -> skip)		S12, S13, CI

check(n == 1) :
目标语义 : (<LOG-EXP> != 0 -> σ(<STA-LIST>) || <LOG-EXP> == 0 -> skip)
推导序列证据 : S12
目标语义和推理出的语义是否一致 : true

check(n == N + 1) :
目标语义 : ({<LOG-EXP> != 0 -> σ(<STA-LIST>)} ** (N + 1) || <LOG-EXP> == 0 -> skip)
推导序列证据 : S14
目标语义和推理出的语义是否一致 : true

综上，给定的目标语义和推理出的语义是否一致 :
true
while语句验证结果 : 验证成功
while语句验证结束!

for语句验证开始...
for : 3.16

==============目标码模式===============
<ASS-EXP_1>
b .L2
.L1:
<STA-LIST>
<ASS-EXP_2>
.L2:
<LOG-EXP>
cmpi 7,0,0,0
bne 7,.L1

==============目标码模式命题===============
P1 = <ASS-EXP_1>
P2 = PC = PC + @.L2
P3 = .L1:
P4 = <STA-LIST>
P5 = <ASS-EXP_2>
P6 = .L2:
P7 = GPR[0] = <LOG-EXP>
P8 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001
P9 = CR[7] == b100 -> PC = PC + @.L1 || CR[7] == b010 -> PC = PC + @.L1 || CR[7] == b001 -> PC = PC + 4

=================循环交互证明算法===================
用户输入的语义 :
σ(<ASS-EXP_1>)
{<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** n || <LOG-EXP> == 0 -> skip

辅助前提 :
P0 = (σ(<ASS-EXP_1>)) ∧ ({<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** n || <LOG-EXP> == 0 -> skip)

推导序列 :
S1 = <ASS-EXP_1>		P1
S2 = PC = PC + @.L2		P2
S3 = .L1:		P3
S4 = <STA-LIST>		P4
S5 = <ASS-EXP_2>		P5
S6 = .L2:		P6
S7 = GPR[0] = <LOG-EXP>		P7
S8 = GPR[0] < 0 -> CR[7] = b100 || GPR[0] > 0 -> CR[7] = b010 || GPR[0] == 0 -> CR[7] = b001		P8
S9 = <LOG-EXP> < 0 -> CR[7] = b100 || <LOG-EXP> > 0 -> CR[7] = b010 || <LOG-EXP> == 0 -> CR[7] = b001		S7,S8,MP
S10 = CR[7] == b100 -> PC = PC + @.L1 || CR[7] == b010 -> PC = PC + @.L1 || CR[7] == b001 -> PC = PC + 4		P9
S11 = <LOG-EXP> < 0 -> PC = PC + @.L1 || <LOG-EXP> > 0 -> PC = PC + @.L1 || <LOG-EXP> == 0 -> PC = PC + 4		S9,S10,MP
S12 = (<ASS-EXP_1>) ∧ (PC = PC + @.L2) ∧ (.L1:) ∧ (<STA-LIST>) ∧ (<ASS-EXP_2>) ∧ (.L2:) ∧ (<LOG-EXP> < 0 -> PC = PC + @.L1 || <LOG-EXP> > 0 -> PC = PC + @.L1 || <LOG-EXP> == 0 -> PC = PC + 4)		S1, S2, S3, S4, S5, S6, S11, CI
S13 = (<ASS-EXP_1>) ∧ (<LOG-EXP> != 0 -> <STA-LIST>; <ASS-EXP_2> || <LOG-EXP> == 0 -> null)		S12, REDUCE
S14 = (σ(<ASS-EXP_1>)) ∧ (<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)] || <LOG-EXP> == 0 -> skip)		S13, σ
S15 = (σ(<ASS-EXP_1>)) ∧ ({<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** N || <LOG-EXP> == 0 -> skip)		P0, n = N
S16 = (σ(<ASS-EXP_1>)) ∧ ({<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** (N + 1) || <LOG-EXP> == 0 -> skip)		S14, S15, CI

check(n == 1) :
目标语义 : (σ(<ASS-EXP_1>)) ∧ (<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)] || <LOG-EXP> == 0 -> skip)
推导序列证据 : S14
目标语义和推理出的语义是否一致 : true

check(n == N + 1) :
目标语义 : (σ(<ASS-EXP_1>)) ∧ ({<LOG-EXP> != 0 -> [σ(<STA-LIST>); σ(<ASS-EXP_2>)]} ** (N + 1) || <LOG-EXP> == 0 -> skip)
推导序列证据 : S16
目标语义和推理出的语义是否一致 : true

综上，给定的目标语义和推理出的语义是否一致 :
true
for语句验证结果 : 验证成功
for语句验证结束!

目标码生成结束!
===================Assembler==================

	.section .rodata
	.align 2                               # 3.5
.LC0:	                                  # 3.5
	.string	"%d %d"                        # 3.5
	.align 2                               # 3.9
.LC4:	                                  # 3.9
	.string	"c is %d for the first time!"  # 3.9
	.align 2                               # 3.10
.LC5:	                                  # 3.10
	.string	"%d"                           # 3.10

	.align 2                               # 3.15
.LC8:	                                  # 3.15
	.string	"The biggest sqrt root of %d is %d"# 3.15

	.section ".text"
	.align 2                               # 3
	.globl main                            # 3
	.type main, @function                  # 3
main:	                                  # 3
	stwu 1,-32(1)                          # 3
	mflr 0                                 # 3
	stw 31,28(1)                           # 3
	stw 0,36(1)                            # 3
	mr 31,1                                # 3

	lis 0,.LC0@ha                          # 3.5
	addic 10,0,.LC0@l                      # 3.5
	mr 3,10                                # 3.5
	addi 11,31,8                           # 3.5
	mr 4,11                                # 3.5
	addi 12,31,12                          # 3.5
	mr 5,12                                # 3.5
	crxor 6,6,6                            # 3.5
	bl __isoc99_scanf                      # 3.5

	li 0,0                                 # 3.6
	stw 0,16(31)                           # 3.6

.L1:	                                   # 3.7
	lwz 0,8(31)                            # 3.7.1
	li 9,2                                 # 3.7.1
	divw 11,0,9                            # 3.7.1
	mullw 9,11,9                           # 3.7.1
	subf 0,9,0                             # 3.7.1
	stw 0,24(31)                           # 3.7.1

	lwz 0,24(31)                           # 3.7.1
	li 9,0                                 # 3.7.1
	cmp 7,0,0,9                            # 3.7.1
	li 0,0                                 # 3.7.1
	li 9,1                                 # 3.7.1
	isel 0,9,0,30                          # 3.7.1
	stw 0,28(31)                           # 3.7.1

	lwz 0,28(31)                           # 3.7.1
	cmpi 7,0,0,0                           # 3.7.1
	beq 7,.L2                              # 3.7.1

	lwz 9,8(31)                            # 3.7.1.1
	li 0,2                                 # 3.7.1.1
	mullw 0,9,0                            # 3.7.1.1
	stw 0,24(31)                           # 3.7.1.1

	lwz 9,16(31)                           # 3.7.1.1
	lwz 0,24(31)                           # 3.7.1.1
	subf 0,9,0                             # 3.7.1.1
	stw 0,28(31)                           # 3.7.1.1

	lwz 0,28(31)                           # 3.7.1.1
	stw 0,16(31)                           # 3.7.1.1

.L2:	                                   # 3.7.1

	lwz 9,8(31)                            # 3.7.3
	li 0,2                                 # 3.7.3
	mullw 0,9,0                            # 3.7.3
	stw 0,24(31)                           # 3.7.3

	lwz 9,16(31)                           # 3.7.3
	lwz 0,24(31)                           # 3.7.3
	add 0,9,0                              # 3.7.3
	stw 0,28(31)                           # 3.7.3

	lwz 0,28(31)                           # 3.7.3
	stw 0,16(31)                           # 3.7.3

	lwz 0,8(31)                            # 3.7.4
	addic 0,0,1                            # 3.7.4
	stw 0,8(31)                            # 3.7.4

	lwz 0,8(31)                            # 3.8
	lwz 9,12(31)                           # 3.8
	cmp 7,0,0,9                            # 3.8
	li 0,0                                 # 3.8
	li 9,1                                 # 3.8
	isel 0,9,0,28                          # 3.8
	stw 0,24(31)                           # 3.8

	lwz 0,24(31)                           # 3.7
	cmpi 7,0,0,0                           # 3.7
	bne 7,.L1                              # 3.7

	lis 0,.LC4@ha                          # 3.9
	addic 0,0,.LC4@l                       # 3.9
	mr 3,0                                 # 3.9
	lwz 4,16(31)                           # 3.9
	crxor 6,6,6                            # 3.9
	bl printf                              # 3.9

	lis 0,.LC5@ha                          # 3.10
	addic 10,0,.LC5@l                      # 3.10
	mr 3,10                                # 3.10
	addi 11,31,8                           # 3.10
	mr 4,11                                # 3.10
	crxor 6,6,6                            # 3.10
	bl __isoc99_scanf                      # 3.10

	li 0,1                                 # 3.11
	stw 0,12(31)                           # 3.11

	lwz 9,12(31)                           # 3.12
	lwz 0,12(31)                           # 3.12
	mullw 0,9,0                            # 3.12
	stw 0,24(31)                           # 3.12

	lwz 0,24(31)                           # 3.12
	stw 0,16(31)                           # 3.12

	b .L6                                  # 3.13
.L7:	                                   # 3.13
	lwz 0,12(31)                           # 3.13.1
	addic 0,0,1                            # 3.13.1
	stw 0,12(31)                           # 3.13.1

	lwz 9,12(31)                           # 3.13.2
	lwz 0,12(31)                           # 3.13.2
	mullw 0,9,0                            # 3.13.2
	stw 0,24(31)                           # 3.13.2

	lwz 0,24(31)                           # 3.13.2
	stw 0,16(31)                           # 3.13.2

.L6:	                                   # 3.13
	lwz 0,16(31)                           # 3.13
	lwz 9,8(31)                            # 3.13
	cmp 7,0,0,9                            # 3.13
	li 0,0                                 # 3.13
	li 9,1                                 # 3.13
	isel 0,9,0,28                          # 3.13
	stw 0,24(31)                           # 3.13

	lwz 0,24(31)                           # 3.13
	cmpi 7,0,0,0                           # 3.13
	bne 7,.L7                              # 3.13
	lis 0,.LC8@ha                          # 3.15
	addic 0,0,.LC8@l                       # 3.15
	mr 3,0                                 # 3.15
	lwz 4,8(31)                            # 3.15
	lwz 5,12(31)                           # 3.15
	crxor 6,6,6                            # 3.15
	bl printf                              # 3.15

	li 0,0                                 # 3.16
	stw 0,8(31)                            # 3.16

	b .L9                                  # 3.16
.L10:	                                  # 3.16
	lwz 0,12(31)                           # 3.16.1
	addic 0,0,1                            # 3.16.1
	stw 0,12(31)                           # 3.16.1

	lwz 0,8(31)                            # 3.16
	addic 0,0,1                            # 3.16
	stw 0,8(31)                            # 3.16

.L9:	                                   # 3.16
	lwz 0,8(31)                            # 3.16
	li 9,10                                # 3.16
	cmp 7,0,0,9                            # 3.16
	li 0,0                                 # 3.16
	li 9,1                                 # 3.16
	isel 0,9,0,28                          # 3.16
	stw 0,24(31)                           # 3.16

	lwz 0,24(31)                           # 3.16
	cmpi 7,0,0,0                           # 3.16
	bne 7,.L10                             # 3.16

	li 0,0                                 # 3.18
	mr 3,0                                 # 3.18
	lwz 11,0(1)                            # 3
	lwz 0,4(11)                            # 3
	mtlr 0                                 # 3
	lwz 31,-4(11)                          # 3
	mr 1,11                                # 3
	blr                                    # 3
	.size main,.-main                      # 3
